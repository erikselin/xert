<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>xrtproject.io</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css">
    <script defer src="https://use.fontawesome.com/releases/v5.0.7/js/all.js"></script>
    <style>
      .tabs.is-toggle li.is-active a {
        background-color: #363636;
        border-color: #363636;
      border-radius: 0px;
      }
      .tabs.is-toggle li:first-child a {
      border-radius: 0px;
      }
      .tabs.is-toggle li:last-child a {
      border-radius: 0px;
      }
      .button {
      border-radius: 0px;
      }
      .content .tag, .content .number {
        display: inline;
        padding: inherit;
        font-size: inherit;
        line-height: inherit;
        text-align: inherit;
        vertical-align: inherit;
        border-radius: inherit;
        font-weight: inherit;
        white-space: inherit;
        background: inherit;
        margin: inherit;
      }
    </style>
    <script type="text/javascript">
      function switchTo(lang) {
        var langs = ['python', 'ruby', 'php', 'c#', 'go'];
        for (var i = 0; i < langs.length; ++i) {
          button = document.getElementById(langs[i]+'-button');
          run = document.getElementById(langs[i]+'-run');
          code = document.getElementById(langs[i]+'-code');
          button.classList.remove('is-active');
          run.style.display = "none";
          code.style.display = "none";
          if (lang == langs[i]) {
            button.classList.add('is-active');
            run.style.display = "block";
            code.style.display = "block";
          }
        }
      }
    </script>
  </head>
  <body>
    <section class="hero is-dark is-bold is-fullheight" style="background: url('images/fox.jpg')center center; background-size:cover;">
      <div class="hero-body">
        <div class="container">
          <h1 class="title" style="font-size:6rem">
XRT
          </h1>
          <h2 class="subtitle is-2">
Simple Data Processing
          </h2>
          <a href="https://github.com/erikselin/xrt/releases" class="button is-dark is-inverted is-outlined is-medium">
            <span class="icon"><i class="fab fa-github"></i></span>
            <span>
Download
            </span>
          </a>
        </div>
      </div>
      <div class="hero-foot">
        <div class="container has-text-centered">
          <p>
            <span class="icon"><i class="fas fa-3x fa-angle-double-down"></i></span>
          </p>
        </div>
      </div>
    </section>


    <section class="hero is-medium">
      <div class="hero-body">
        <div class="container">
          <h1 class="title">
INTRODUCTION
          </h1>
          <p class="is-size-5">
XRT is a programming-language-independent and resource-aware MapReduce runtime for multi-core systems.
It can turn anything from resource-constrained single-board computers to large servers, with over a hundred cores, into high-performance data-processing environments.
          </p>
          <br>
          <div class="columns is-variable is-6">
            <div class="column">
              <p class="subtitle"><strong>
FOR MEDIUM-DATA PROBLEMS
              </strong></p>
              <p>
Most organizations do not have the data volumes to justify cluster-based data-processing.
XRT is an exploration of what a data-processing system might look like if built with medium-data problems in mind.
              </p>
            </div>
            <div class="column">
              <p class="subtitle"><strong>
ANY PROGRAMMING-LANGUAGE
              </strong></p>
              <p>
Why is it considered reasonable to maintain a separate data-stack from the production-stack?
XRT encourages collaboration across all codebases and teams by enabling data processing in the same programming languages used in other parts of the organization.
              </p>
            </div>
          </div>
          <div class="columns is-variable is-6">
            <div class="column">
              <p class="subtitle"><strong>
LOW-LEVEL
              </strong></p>
              <p>
When you reach out for a general programming language to solve data problems you are likely looking for flexibility or performance.
XRT offers both by using a flexible MapReduce programming model while simultaneously providing high performance through low-level optimizations.
              </p>
            </div>
            <div class="column">
              <p class="subtitle"><strong>
SIMPLE
              </strong></p>
              <p>
XRT differs philosophically from most data-processing systems by being composed of a small set of carefully chosen features.
Also, XRT has zero-configuration, a single-binary deployment and cross-platform compatibility resulting in low operational overhead and quick bootstrapping of development environments.
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="hero is-medium is-light">
      <div class="hero-body">
        <div class="container">
          <h1 class="title">
THE RUNTIME
          </h1>
          <p class="is-size-5">
The classical MapReduce programming model is a constant source of inspiration for XRT.
However, to enable various features, the XRT runtime contains some fundamental differences.
These differences make it easy to reason about the runtime, facilitates development and help in delivering top performance.
          </p>
          <br>
          <div class="tile is-ancestor">
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
MULTI-CORE ONLY
                </strong></p>
                <p>
XRT is built to scale vertically on modern high core-count systems instead of horizontally across a cluster.
As a result, XRT will benefit from high parallelism but avoids the performance implications and operational overhead of traditional cluster-based data processing runtimes.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
NEWLINE-SEPARATED DATA
                </strong></p>
                <p>
To enable the programming-language independent capabilities, XRT only includes native support for reading and writing newline-separated data formats.
However, XRT can be extended to process any data format by implementing the read or write logic within the mapper or reducer.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
PROCESS-BASED PARALLELISM
                </strong></p>
                <p>
XRT enables parallel data processing by spawning multiple mappers and reducers as subprocesses and connecting them with the XRT runtime over stdin and stdout.
This model, influenced by Hadoop Streaming, enables any programming language that can read and write from the standard streams to work with XRT.
                </p>
              </article>
            </div>
          </div>
          <div class="tile is-ancestor">
            <div class="tile is-parent">
          <a href="images/plot.jpg"><img src="images/plot.jpg"></a>
            </div>
          </div>
          <div class="tile is-ancestor">
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
RESOURCE-AWARE
                </strong></p>
                <p>
XRT attempts to keep all intermediate data in memory to ensure optimal performance whenever possible.
However, resource-awareness is a core concern, and XRT is capable of utilizing efficient disk-based data structures for processing vast volumes of data.
In a recent test, XRT efficiently sorted 100Gb using 1Gb of memory.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
PERFORMANCE
                </strong></p>
                <p>
In current benchmarks, optimized XRT jobs are on average 2x faster than equivalent Apache Spark jobs when running on the same high core-count system.
When XRT is run on a single high core-count system and Apache Spark on a networked cluster with an equal number of cores, the performance difference is even greater.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
FLEXIBLE
                </strong></p>
                <p>
XRT enables a flexible data processing environment by making input, output and reducer optional.
Running a map-only job is very common for injective transformations like simple parallelized ETL problems.
Omitting input or output is common when input or output logic is implemented within the mapper or reducer code directly.
                </p>
              </article>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="hero is-medium">
      <div class="hero-body">
        <div class="container">
          <h1 class="title">
A QUICK EXAMPLE
          </h1>
          <p class="is-size-5">
Consider a dataset of user interactions split into multiple files:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="text content">input/part-0
input/part-1
...</code></pre>
          <br>
          <p class="is-size-5">
Each row of each file contains information about a particular interaction where the first column contains a user-id:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="text content">283913	...
957294	...
973849	...
104582	...
...
</code></pre>
          <br>
          <p class="is-size-5">
The problem to solve is to count the total number of interactions per user using programing-language:
          </p>
          <br>
          <div class="tabs is-centered is-toggle is-dark">
            <ul>
              <li id="python-button" class="is-active"><a href="javascript:switchTo('python')">Python</a></li>
              <li id="ruby-button" ><a href="javascript:switchTo('ruby')">Ruby</a></li>
              <li id="php-button" ><a href="javascript:switchTo('php')">PHP</a></li>
              <li id="c#-button" ><a href="javascript:switchTo('c#')">C#</a></li>
              <li id="go-button" ><a href="javascript:switchTo('go')">Go</a></li>
            </ul>
          </div>
          <p class="is-size-5">
The XRT invocation to use 4 mappers, 4 reducers and a maximum of 2g of memory is as follows:
          </p>
          <br>

<!-- ##### run commands ####################################################################### -->

<pre id="python-run" style="background-color: #f5f5f5;"><code class="bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper <i>"python useractivity.py map"</i> \
    --reducer <i>"python useractivity.py reduce"</i> \
    --output output</code></pre>

<pre id="ruby-run" style="display: none; background-color: #f5f5f5;"><code class="bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper <i>"ruby useractivity.rb map"</i> \
    --reducer <i>"ruby useractivity.rb reduce"</i> \
    --output output</code></pre>

<pre id="php-run" style="display: none; background-color: #f5f5f5;"><code class="bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper <i>"php useractivity.php map"</i> \
    --reducer <i>"php useractivity.php reduce"</i> \
    --output output</code></pre>

<pre id="c#-run" style="display: none; background-color: #f5f5f5;"><code class="bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper <i>"./useractivity map"</i> \
    --reducer <i>"./useractivity reduce"</i> \
    --output output</code></pre>

<pre id="go-run" style="display: none; background-color: #f5f5f5;"><code class="bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper <i>"./useractivity map"</i> \
    --reducer <i>"./useractivity reduce"</i> \
    --output output</code></pre>

<!-- ##### end run commands ################################################################### -->

          <br>
          <p class="is-size-5">
Where the --mapper and --reducer are the commands used to spawn the mapper and reducer subprocesses.
For the mapper, we read lines from stdin, split them into the columns and then assign a reducer-id based on the user-id ensuring that each identical user-id will get processed by the same reducer.
The reducer reads a sorted stream of user-ids from stdin while keeping a running tally and emitting a user-id to count pair when it encounters a new user-id.
          </p>
          <br>

<!-- ##### code #####$$$$###################################################################### -->

<pre id="python-code" style="background-color: #f5f5f5;"><code class="content"><b>from</b> os <b>import</b> environ
<b>from</b> sys <b>import</b> argv, stdin, stdout

<b>def</b> <i>mapper</i>():
    reducers = <b>int</b>(environ[<i>'REDUCERS'</i>])
    <b>for</b> line <b>in</b> stdin:
        uid = <b>int</b>(line.split(<i>'\t'</i>)[0])
        rid = uid % reducers
        stdout.write(<i>f'{rid}\t{uid}\n'</i>)

<b>def</b> <i>reducer</i>():
    uid = stdin.readline().rstrip()
    count = 1
    <b>for</b> line <b>in</b> stdin:
        line = line.rstrip()
        <b>if</b> uid != line:
            stdout.write(<i>f'{uid}\t{count}\n'</i>)
            uid = line
            count = 0
        count += 1
    stdout.write(<i>f'{uid}\t{count}\n'</i>)

<b>if</b> argv[1] == <i>'map'</i>:
    mapper()
<b>if</b> argv[1] == <i>'reduce'</i>:
    reducer()</code></pre>

<pre id="ruby-code" style="display: none; background-color: #f5f5f5;"><code class="ruby content"><b>def</b> <i>mapper</i>
  reducers = ENV[<i>'REDUCERS'</i>].to_i
  STDIN.each <b>do</b> |line|
    uid = line.split(<i>'\t'</i>).first.to_i
    rid = uid % reducers
    STDOUT.write <i>"#{rid}\t#{uid}\n"</i>
  <b>end</b>
<b>end</b>

<b>def</b> <i>reducer</i>
  uid = STDIN.readline.rstrip
  count = 1
  STDIN.each <b>do</b> |line|
    line.rstrip!
    <b>if</b> uid != line
      STDOUT.write <i>"#{uid}\t#{count}\n"</i>
      uid = line
      count = 0
    <b>end</b>
    count += 1
  <b>end</b>
  STDOUT.write <i>"#{uid}\t#{count}\n"</i>
<b>end</b>

<b>case</b> ARGV[0]
<b>when</b> <i>"map"</i>
  mapper
<b>when</b> <i>"reduce"</i>
  reducer
<b>end</b></code></pre>

<pre id="php-code" style="display: none; background-color: #f5f5f5;"><code class="php content"><b>&#60;?php</b>

<b>function</b> <i>mapper</i>() {
    $reducers = (int)$_ENV[<i>"REDUCERS"</i>];
    <b>while</b>($line = fgets(STDIN)) {
        $uid = (int)explode(<i>"\t"</i>, $line)[0];
        $rid = $uid % $reducers;
        echo <i>"line: $rid\t$uid\n"</i>;
    }
}

<b>function</b> <i>reducer</i>() {
    $uid = rtrim(fgets(STDIN));
    $count = 1;
    <b>while</b>($line = fgets(STDIN)) {
        $line = rtrim($line);
        <b>if</b> ($uid != $line) {
            echo <i>"$uid\t$count\n"</i>;
            $uid = $line;
            $count = 0;
        }
        $count++;
    }
    echo <i>"$uid\t$count\n"</i>;
}

<b>switch</b>($argv[1]) {
    case <i>"map"</i>:
        mapper();
        break;
    case <i>"reduce"</i>:
        reducer();
        break;
}

<b>?&#62;</b></code></pre>

<pre id="c#-code" style="display: none; background-color: #f5f5f5;"><code class="csharp content"><b>using</b> System;

<b>namespace</b> userActivity
{
    <b>class</b> Program
    {
        <b>static</b> void <i>mapper</i>()
        {
            var reducers = Int32.Parse(Environment.GetEnvironmentVariable(<i>"REDUCERS"</i>));
            <b>for</b> (var line = Console.ReadLine(); line != null; line = Console.ReadLine()) {
                var uid = Int32.Parse(line.Split(<i>'\t'</i>)[0]);
                var rid = uid % reducers;
                Console.WriteLine(<i>$"{rid}\t{uid}"</i>);
            }
        }

        <b>static</b> void <i>reducer</i>()
        {
            var uid = Console.ReadLine();
            var count = 1;
            for (string line = Console.ReadLine(); line != null; line = Console.ReadLine()) {
                if (uid != line) {
                    Console.WriteLine(<i>$"{uid}\t{count}"</i>);
                    uid = line;
                    count = 0;
                }
                count++;
            }
            Console.WriteLine(<i>$"{uid}\t{count}"</i>);
        }

        <b>static</b> void <i>Main</i>(string[] args)
        {
            switch(args[1]) {
            case <i>"map"</i>:
                mapper();
                break;
            case <i>"reduce"</i>:
                reducer();
                break;
            }
        }
    }
}</code></pre>

<pre id="go-code" style="display: none; background-color: #f5f5f5;"><code class="go content"><b>package</b> main

<b>import</b> (
	<i>"bufio"</i>
	<i>"fmt"</i>
	<i>"log"</i>
	<i>"os"</i>
	<i>"strconv"</i>
	<i>"strings"</i>
)

<b>func</b> <i>mapper</i>() error {
	s := bufio.NewScanner(os.Stdin)
	w := bufio.NewWriter(os.Stdout)
	reducers, err := strconv.Atoi(os.Getenv(<i>"REDUCERS"</i>))
	<b>if</b> err != nil {
		<b>return</b> err
	}
	<b>for</b> s.Scan() {
		uid, err := strconv.Atoi(strings.Split(s.Text(), <i>"\t"</i>)[0])
		<b>if</b> err != nil {
			<b>return</b> err
		}
		rid := uid % reducers
		<b>if</b> _, err := fmt.Fprintf(w, <i>"%d\t%d\n"</i>, rid, uid); err != nil {
			<b>return</b> err
		}
	}
	<b>if</b> err := s.Err(); err != nil {
		<b>return</b> err
	}
	<b>return</b> w.Flush()
}

<b>func</b> <i>reducer</i>() error {
	s := bufio.NewScanner(os.Stdin)
	w := bufio.NewWriter(os.Stdout)
	<b>if</b> !s.Scan() {
		<b>return</b> s.Err()
	}
	uid := s.Text()
	count := 1
	<b>for</b> s.Scan() {
		<b>if</b> uid != s.Text() {
			if _, err := fmt.Fprintf(w, <i>"%s\t%d\n"</i>, uid, count); err != nil {
				<b>return</b> err
			}
			uid = s.Text()
			count = 0
		}
		count++
	}
	<b>if</b> err := s.Err(); err != nil {
		<b>return</b> err
	}
	<b>if</b> _, err := fmt.Fprintf(w, <i>"%s\t%d\n"</i>, uid, count); err != nil {
		<b>return</b> err
	}
	<b>return</b> w.Flush()
}

<b>func</b> <i>main</i>() {
	var err error
	<b>switch</b> os.Args[1] {
	<b>case</b> <i>"map"</i>:
		err = mapper()
	<b>case</b> <i>"reduce"</i>:
		err = reducer()
	}
	<b>if</b> err != nil {
		log.Fatal(err)
	}
}</code></pre>

<!-- ##### end code ####$$$$################################################################### -->

          <br>
          <p class="is-size-5">
The final output will end up as part files in the --output directory:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="text content">output/part-0
output/part-1
output/part-2
output/part-3</code></pre>
          <br>
          <p class="is-size-5">
Where each part file would contain the user-id to count emitted by the reducers:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="text content">283913	142
957294	4
973849	40
104582	32
...</code></pre>

        </div>
      </div>
    </section>

    <section class="hero is-dark is-medium">
      <div class="hero-body">
        <div class="container has-text-centered">
<!-- <a class="button is-dark is-inverted is-outlined is-medium">Documentation</a> -->
<a href="https://github.com/erikselin/xrt" class="button is-dark is-inverted is-outlined is-medium"><span class="icon"><i class="fab fa-github"></i></span><span>Download</span></a>
        </div>
      </div>
    </section>
  </body>
</html>
