<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>xrtproject.io</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/themes/prism.min.css">
    <script defer src="https://use.fontawesome.com/releases/v5.0.7/js/all.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/prism.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/components/prism-bash.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/components/prism-python.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/components/prism-ruby.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/components/prism-go.min.js"></script>
    <style>
      .tabs.is-toggle li.is-active a {
        background-color: #363636;
        border-color: #363636;
      border-radius: 0px;
      }
      .tabs.is-toggle li:first-child a {
      border-radius: 0px;
      }
      .tabs.is-toggle li:last-child a {
      border-radius: 0px;
      }
      .button {
      border-radius: 0px;
      }
      .content .tag, .content .number {
        display: inline;
        padding: inherit;
        font-size: inherit;
        line-height: inherit;
        text-align: inherit;
        vertical-align: inherit;
        border-radius: inherit;
        font-weight: inherit;
        white-space: inherit;
        background: inherit;
        margin: inherit;
      }
    </style>
    <script type="text/javascript">
      function switchTo(lang) {
        var langs = ['python', 'ruby', 'clojure', 'node', 'go'];
        for (var i = 0; i < langs.length; ++i) {
          button = document.getElementById(langs[i]+'-button');
          run = document.getElementById(langs[i]+'-run');
          code = document.getElementById(langs[i]+'-code');
          button.classList.remove('is-active');
          run.style.display = "none";
          code.style.display = "none";
          if (lang == langs[i]) {
            button.classList.add('is-active');
            run.style.display = "block";
            code.style.display = "block";
          }
        }
      }
    </script>
  </head>
  <body>
    <section class="hero is-dark is-bold is-fullheight" style="background: url('fox.jpg')center center; background-size:cover;">
      <div class="hero-body">
        <div class="container">
          <h1 class="title" style="font-size:6rem">
XRT
          </h1>
          <h2 class="subtitle is-2">
Simple Data Processing
          </h2>
          <!-- <a class="button is-dark is-inverted is-outlined is-medium">
Documentation
          </a> -->
          <a href="https://github.com/erikselin/xrt/releases" class="button is-dark is-inverted is-outlined is-medium">
            <span class="icon"><i class="fab fa-github"></i></span>
            <span>
Download
            </span>
          </a>
        </div>
      </div>
      <div class="hero-foot">
        <div class="container has-text-centered">
          <p>
            <span class="icon"><i class="fas fa-3x fa-angle-double-down"></i></span>
          </p>
        </div>
      </div>
    </section>


    <section class="hero is-medium">
      <div class="hero-body">
        <div class="container">
          <h1 class="title">
INTRODUCTION
          </h1>
          <p class="is-size-5">
XRT is a programming-language-independent and resource-aware MapReduce runtime for multi-core systems.
It can turn anything from resource-constrained single-board computers to large servers, with over a hundred cores, into high-performance parallelized data processing environments.
          </p>
          <br>
          <div class="columns is-variable is-6">
            <div class="column">
              <p class="subtitle"><strong>
FOR MEDIUM-DATA PROBLEMS
              </strong></p>
              <p>
Most organizations do not have the data volumes to justify a clustered approach for large-scale data processing.
XRT is an exploration of what a system might look like if built with medium-data problems in mind.
              </p>
            </div>
            <div class="column">
              <p class="subtitle"><strong>
ANY PROGRAMMING-LANGUAGE
              </strong></p>
              <p>
Why is it considered normal to maintain a separate data-stack from the production-stack?
XRT encourages collaboration across all codebases and teams by enabling data processing in the same programming languages used in other parts of the organization.
              </p>
            </div>
          </div>
          <div class="columns is-variable is-6">
            <div class="column">
              <p class="subtitle"><strong>
LOW-LEVEL
              </strong></p>
              <p>
When you reach out for a general programming language to solve data problems you are likely looking for flexibility or performance.
XRT offers both by using a flexible MapReduce programming model while simultaneously offering high performance through low-level optimizations.
              </p>
            </div>
            <div class="column">
              <p class="subtitle"><strong>
SIMPLE
              </strong></p>
              <p>
XRT differs philosophically from most data-processing systems by being composed of a small set of carefully chosen features instead of hiding complexities behind a sea of features.
As a result, XRT encourages mastering the runtime through a deep understanding of how your data is being processed.
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="hero is-medium is-light">
      <div class="hero-body">
        <div class="container">
          <h1 class="title">
THE RUNTIME
          </h1>
          <p class="is-size-5">
          </p>
          <br>
          <div class="tile is-ancestor">
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
MULTI-CORE ONLY
                </strong></p>
                <p>
XRT is built to scale vertically on modern high core-count systems instead of horizontally across a cluster.
As a result, XRT benefits from high parallelism but avoids the performance implications and operational overhead of traditional cluster-based data processing runtimes.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
NEWLINE-SEPARATED DATA
                </strong></p>
                <p>
To enable the programming-language independent capacities, XRT only operates on newline-separated data formats.
For example, it is very easy to start processing csv, tsv,newline-separated json, etc. with XRT.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
PROCESS-BASED PARALLELISM
                </strong></p>
                <p>
XRT enables parallel data processing by spawning multiple mapper processes and reducer processes and connecting them using stdin/stdout.
This model, influenced by Hadoop Streaming, is really central to the programming-language independent capabilities of XRT.
                </p>
              </article>
            </div>
          </div>
          <div class="tile is-ancestor">
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
RESOURCE-AWARE
                </strong></p>
                <p>
XRT attempts to keep all intermediate data in memory to ensure optimal performance whenever possible.
However, resource-awareness is a core feature and XRT is capable of utilizing efficient disk-based data structures for processing very large volumes of data.
In fact, in a recent test, XRT efficiently sorted 100Gb using 1Gb of memory.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
PERFORMANCE
                </strong></p>
                <p>
In our benchmarks, XRT is on average 2x faster than Apache Spark when running on the same high core-count instance.
When XRT is run on a single high core-count instance and Apache Spark on a cluster with the same total number of cores the performance difference is even greater.
                </p>
              </article>
            </div>
            <div class="tile is-parent">
              <article class="tile is-child notification" style="background-color: #FFF;">
                <p class="subtitle"><strong>
SIMPLE OPERATIONS
                </strong></p>
                <p>
XRT is zero-configuration and uses a single-binary deployment.
The operational overhead of setting up an XRT environment is simply to download the binary and copy it to your server.
In addition, since XRT runs on a single server environment and dependecy management is very simple.
                </p>
              </article>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="hero is-medium">
      <div class="hero-body">
        <div class="container">
          <h1 class="title">
A QUICK EXAMPLE
          </h1>
          <p class="is-size-5">
Consider a dataset of user interactions split into multiple files:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="language-text content">input/part-0
input/part-1
...</code></pre>
          <br>
          <p class="is-size-5">
Where the content of each file contains rows of two columns. The first column contains a user-id
and the second column the time of the user interaction. The data might look like this:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="language-text content">...
283913	2018-06-08T03:44:04
957294	2018-06-08T03:44:10
973849	2018-06-08T03:44:34
104582	2018-06-08T03:45:01
...
</code></pre>
          <br>
          <p class="is-size-5">
The problem is to count the total number of interactions per user using programing-language:
          </p>
          <br>
          <div class="tabs is-centered is-toggle is-dark">
            <ul>
              <li id="python-button" class="is-active"><a href="javascript:switchTo('python')">Python</a></li>
              <li id="ruby-button" ><a href="javascript:switchTo('ruby')">Ruby</a></li>
              <li id="clojure-button" ><a href="javascript:switchTo('clojure')">Clojure</a></li>
              <li id="node-button" ><a href="javascript:switchTo('node')">Node.js</a></li>
              <li id="go-button" ><a href="javascript:switchTo('go')">Go</a></li>
            </ul>
          </div>
          <p class="is-size-5">
In XRT, if we wanted to use 4 mappers, 4 reducers and 2g of memory to solve this problem we would invoke XRT as follows:
          </p>
          <br>

<!-- ##### run commands ####################################################################### -->

<pre id="python-run" style="background-color: #f5f5f5;"><code class="language-bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper "python wordcount.py map" \
    --reducer "python wordcount.py reduce" \
    --output output</code></pre>

<pre id="ruby-run" style="display: none; background-color: #f5f5f5;"><code class="language-bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper "ruby wordcount.rb map" \
    --reducer "ruby wordcount.rb reduce" \
    --output output</code></pre>

<pre id="clojure-run" style="display: none; background-color: #f5f5f5;"><code class="language-bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper "java -jar wordcount.jar map" \
    --reducer "java -jar wordcount.jar reduce" \
    --output output</code></pre>

<pre id="node-run" style="display: none; background-color: #f5f5f5;"><code class="language-bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper "node wordcount.js map" \
    --reducer "node wordcount.js reduce" \
    --output output</code></pre>

<pre id="go-run" style="display: none; background-color: #f5f5f5;"><code class="language-bash content">xrt --mappers 4 \
    --reducers 4 \
    --memory 2g \
    --input input/part-*.tsv \
    --mapper "./wordcount map" \
    --reducer "./wordcount reduce" \
    --output output</code></pre>

<!-- ##### end run commands ################################################################### -->

          <br>
          <p class="is-size-5">
Where the --mapper and --reducer are the commands used to run the user supplied mapper and reducer
workers. For the mapper we want to read lines from stdin, split them into the columns and then
assign a reducer key based on the user-id ensuring that each identical user-id will get processed
by the same reducer. The reducer reads a sorted stream of user-ids from stdin keeping a running
tally and emiting a user-id to count pair whenever a new user-id is encountered.
          </p>
          <br>

<!-- ##### code #####$$$$###################################################################### -->

<pre id="python-code" style="background-color: #f5f5f5;"><code class="language-python content">from os import environ
from sys import argv, stdin, stdout

def mapper():
    reducers = int(environ['REDUCERS'])
    for line in stdin:
        uid = int(line.split('\t')[0])
        key = uid % reducers
        stdout.write(f'{key}\t{uid}\n')

def reducer():
    uid = stdin.readline().rstrip()
    count = 1
    for line in stdin:
        line = line.rstrip()
        if uid != line:
            stdout.write(f'{uid}\t{count}\n')
            uid = line
            count = 0
        count += 1
    stdout.write(f'{uid}\t{count}\n')

dict(map=mapper, reduce=reducer)[argv[1]]()</code></pre>

<pre id="ruby-code" style="display: none; background-color: #f5f5f5;"><code class="language-ruby content">def mapper
  reducers = ENV['REDUCERS'].to_i
  STDIN.each do |line|
    uid = line.split('\t').first.to_i
    key = uid % reducers
    STDOUT.write "#{key}\t#{uid}\n"
  end
end

def reducer
  uid = STDIN.readline.rstrip
  count = 1
  STDIN.each do |line|
    line.rstrip!
    if uid != line
      STDOUT.write "#{uid}\t#{count}\n"
      uid = line
      count = 0
    end
    count += 1
  end
  STDOUT.write "#{uid}\t#{count}\n"
end

{"map" => Proc.new { mapper }, "reduce" => Proc.new { reducer }}[ARGV[0]].call</code></pre>

<pre id="clojure-code" style="display: none; background-color: #f5f5f5;"><code class="language-clojure content">clojure</code></pre>

<pre id="node-code" style="display: none; background-color: #f5f5f5;"><code class="language-node content">node</code></pre>

<pre id="go-code" style="display: none; background-color: #f5f5f5;"><code class="language-go content">package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

func mapper() error {
	s := bufio.NewScanner(os.Stdin)
	w := bufio.NewWriter(os.Stdout)
	reducers, err := strconv.Atoi(os.Getenv("REDUCERS"))
	if err != nil {
		return err
	}
	for s.Scan() {
		uid, err := strconv.Atoi(strings.Split(s.Text(), "\t")[0])
		if err != nil {
			return err
		}
		key := uid % reducers
		if _, err := fmt.Fprintf(w, "%d\t%d\n", key, uid); err != nil {
			return err
		}
	}
	if err := s.Err(); err != nil {
		return err
	}
	return w.Flush()
}

func reducer() error {
	s := bufio.NewScanner(os.Stdin)
	w := bufio.NewWriter(os.Stdout)
	if !s.Scan() {
		return s.Err()
	}
	uid := s.Text()
	count := 1
	for s.Scan() {
		if uid != s.Text() {
			if _, err := fmt.Fprintf(w, "%s\t%d\n", uid, count); err != nil {
				return err
			}
			uid = s.Text()
			count = 0
		}
		count++
	}
	if err := s.Err(); err != nil {
		return err
	}
	if _, err := fmt.Fprintf(w, "%s\t%d\n", uid, count); err != nil {
		return err
	}
	return w.Flush()
}

func main() {
	fn := map[string]func() error{"map": mapper, "reduce": reducer}[os.Args[1]]
	if err := fn(); err != nil {
		log.Fatal(err)
	}
}</code></pre>

<!-- ##### end code ####$$$$################################################################### -->

          <br>
          <p class="is-size-5">
The final output will end up as part files in the --output directory:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="language-text content">output/part-0
output/part-1
output/part-2
output/part-3</code></pre>
          <br>
          <p class="is-size-5">
Where each part file would contain the user-id to count emitted by the reducers:
          </p>
          <br>
          <pre style="background-color: #f5f5f5;"><code class="language-text content">...
283913	142
957294	4
973849	40
104582	32
...</code></pre>

        </div>
      </div>
    </section>

    <section class="hero is-dark is-medium">
      <div class="hero-body">
        <div class="container has-text-centered">
<!-- <a class="button is-dark is-inverted is-outlined is-medium">Documentation</a> -->
<a href="https://github.com/erikselin/xrt" class="button is-dark is-inverted is-outlined is-medium"><span class="icon"><i class="fab fa-github"></i></span><span>Download</span></a>
        </div>
      </div>
    </section>
  </body>
</html>
